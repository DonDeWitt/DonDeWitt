::::::::::::::
Driver.java
::::::::::::::
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Driver<K,V>
{
    public static void main(String args[]) throws IOException
    {
        System.out.println("0. Display the content of the symbol table\n" +
                           "1. Insert a symbol key with an associated value in the table\n" +
                           "2. Delete a symbol from the table\r\n" +
                           "3. Retrieve and display the value associated with a symbol key in the table\r\n" +
                           "4. Display the hash index of a symbol key\r\n" +
                           "5. Exit program");

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        HashTable<String, Integer> hT = new HashTable<>();

        boolean on = true;
        while(on)
        {
            System.out.println("\n" + "Enter a number: ");
            int i = Integer.parseInt(br.readLine().trim());
            System.out.println(i);
            switch(i) {
            case 0:
                System.out.println(hT.toString());
                break;
            case 1:
                System.out.println("Enter a symbol: ");
                String symbol = br.readLine().trim().toUpperCase();
                System.out.println(symbol);
                System.out.println("Enter an Integer value: ");
                int value = Integer.parseInt((br.readLine().trim()));
                System.out.println(value);
                if(hT.tableInsert(symbol, value))
                {
                    System.out.println("Added.");
                }
                else
                {
                    System.out.println("Key is already in the table.");
                }
                break;
            case 2:
                System.out.println("Enter entry to be deleted: ");
                String delete = br.readLine().trim().toUpperCase();
                System.out.println(delete);
                if(hT.tableDelete(delete))
                {
                    System.out.println("Deleted.");
                }
                else
                {
                    System.out.println("Unable to find entry '" + delete + "'.");
                }
                break;
            case 3:
                System.out.println("Enter a search key: ");
                String searchKey = br.readLine().trim().toUpperCase();
                System.out.println(searchKey);
                Integer result = hT.tableRetrieve(searchKey);
                if(result != null)
                {
                    System.out.println("Value: " + result);
                }
                else
                {
                    System.out.println("Key not found.");
                }
                break;
            case 4:
                System.out.println("Enter a symbol: ");
                String hK = br.readLine().trim().toUpperCase();
                System.out.println(hK);
                System.out.println("Hash index:" + hT.hashIndex(hK));
                break;
            case 5:
                System.out.println("Closing program...");
                on = false;
                break;
            default:
                System.out.println("Please enter a valid input number 1-5.");
                break;
            }
        }
    }

}
::::::::::::::
HashTable.java
::::::::::::::
// ********************************************************
// Hash table implementation.
// Assumption: A table contains unique items(at most one
//             item with a given search key at any time)
// *********************************************************

public class HashTable<K, V> implements HashTableInterface<K,V> {
    private ChainNode<K,V>[] table;     // hash table
    private int size = 0;          // size of table, i.e. number of entries ((key,value) associations)

    public HashTable() {
        table = new ChainNode[3];
    }  // end default constructor

// table operations
    public boolean tableIsEmpty() {
        return size==0;
    }  // end tableIsEmpty

    public int tableLength() {
        return size;
    }  // end tableLength


//implement the following 5 methods

    public boolean tableInsert(K key, V value) //inserts  association (key,value) only if key is not already in HashTable and returns true; returns false if the key already has an associated value in HashTable and does not insert
    {
        boolean succ = false;
        boolean found = false;
        int index = hashIndex(key)%table.length;
        ChainNode<K,V> curr = table[index];
        if(curr != null)
        {
            for(; curr != null && !succ && !found; curr = curr.getNext())
            {
                if(curr.getKey().equals(key))
                {
                    found = true;
                }
                else if(curr.getNext() == null)
                {
                    curr.setNext(new ChainNode<K,V>(key, value, null));
                    succ = true;
                    size++;
                }
            }
        }
        else
        {
            table[index] = new ChainNode<K,V>(key, value, null);
            succ = true;
            size++;
        }
        return succ;
    }

    public boolean tableDelete(K searchKey) //deletes the key and its association from the HashTable if it is in the table and returns true; returns false if key is not in the HashTable
    {
        boolean succ = false;
        int index = hashIndex(searchKey)%table.length;
        ChainNode<K,V> head = table[index];
        for(ChainNode<K,V> curr = head; curr != null && !succ; curr = curr.getNext())
        {
            ChainNode<K,V> next = curr.getNext();
            if(curr == head && curr.getKey().equals(searchKey))
            {
                if(next != null)
                {
                    table[index] = next;
                }
                else
                {
                    head = null;
                }
                succ = true;
                size--;
            }
            else if(next != null)
            {
                if(next.getKey().equals(searchKey))
                {
                    curr.setNext(next.getNext());
                    succ = true;
                    size--;
                }
            }
        }
        return succ;
    }

    public V tableRetrieve(K searchKey) //returns the value associated with searchkey in HashTable or null if there is no association
    {
        ChainNode<K,V> head = table[hashIndex(searchKey)%table.length];
        V result = null;
        boolean succ = false;
        if(head != null)
        {
            for(ChainNode<K, V> curr = head;
                    curr != null && !succ;
                    curr = curr.getNext())
            {
                if(curr.getKey().equals(searchKey))
                {
                    result = curr.getValue();
                    succ = true;
                }
            }
        }
        return result;
    }

    public int hashIndex(K key)
    {
        String sKey = (String)key;//Convert from K to String
        sKey = sKey.trim().toUpperCase();
        int result = 0;
        int ref = (int)'A';

        for(int i = 0, limit = sKey.length(), exponent = limit-1, mult = 1; i < limit; i++, exponent--, mult = 1)
        {
            if(exponent > 0)
            {
                mult = 32;
                for(int j = 1; j < exponent; j++)
                {
                    mult = mult << 5;
                }
            }
            result += (((int)sKey.charAt(i) - ref)+1) * mult;
        }
        return result;
    }

    public String toString()
    {
        StringBuilder sb = new StringBuilder("Contents:\n");
        if(size > 0)
        {
            for(int i = 0; i < table.length; i++)
            {
                if(table[i] != null)
                {
                    for(ChainNode<K, V> curr = table[i]; curr != null; curr = curr.getNext())
                    {
                        sb.append("Key: " + curr.getKey() + " - Value: " + curr.getValue() + " .\n");
                    }
                }
            }
        }
        else
        {
            sb.append("No contents to display.");
        }
        return sb.toString();
    }
}  // end HashTable
::::::::::::::
output1.output
::::::::::::::
0. Display the content of the symbol table
1. Insert a symbol key with an associated value in the table
2. Delete a symbol from the table
3. Retrieve and display the value associated with a symbol key in the table
4. Display the hash index of a symbol key
5. Exit program

Enter a number: 
0
Contents:
No contents to display.

Enter a number: 
1
Enter a symbol: 
ABCDEF
Enter an Integer value: 
1
Added.

Enter a number: 
1
Enter a symbol: 
ZZZZZZ
Enter an Integer value: 
2
Added.

Enter a number: 
0
Contents:
Key: ABCDEF - Value: 1 .
Key: ZZZZZZ - Value: 2 .


Enter a number: 
1
Enter a symbol: 
YES
Enter an Integer value: 
3
Added.

Enter a number: 
1
Enter a symbol: 
NO
Enter an Integer value: 
4
Added.

Enter a number: 
0
Contents:
Key: ABCDEF - Value: 1 .
Key: ZZZZZZ - Value: 2 .
Key: YES - Value: 3 .
Key: NO - Value: 4 .


Enter a number: 
3
Enter a search key: 
ZZZZZZ
Value: 2

Enter a number: 
3
Enter a search key: 
NO
Value: 4

Enter a number: 
3
Enter a search key: 
YES
Value: 3

Enter a number: 
3
Enter a search key: 
RANDOM
Key not found.

Enter a number: 
2
Enter entry to be deleted: 
ABCDEF
Deleted.

Enter a number: 
0
Contents:
Key: ZZZZZZ - Value: 2 .
Key: YES - Value: 3 .
Key: NO - Value: 4 .


Enter a number: 
2
Enter entry to be deleted: 
ZZZZZZ
Deleted.

Enter a number: 
2
Enter entry to be deleted: 
YES
Deleted.

Enter a number: 
2
Enter entry to be deleted: 
NO
Deleted.

Enter a number: 
0
Contents:
No contents to display.

Enter a number: 
4
Enter a symbol: 
TOP
Hash index:20976

Enter a number: 
4
Enter a symbol: 
OPT
Hash index:15892

Enter a number: 
4
Enter a symbol: 
POT
Hash index:16884

Enter a number: 
4
Enter a symbol: 
ZZZZZZ
Hash index:900557658

Enter a number: 
3
Enter a search key: 
TEST
Key not found.

Enter a number: 
0
Contents:
No contents to display.

Enter a number: 
5
Closing program...
::::::::::::::
conclusions
::::::::::::::
Working on this lab, I learned how to implement hash functions and a hash table using Strings. I also learned how to use and apply Horner's Rule.
